{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/MAMP/htdocs/crystalkeepsakes/src/lib/imageStorageDB.ts"],"sourcesContent":["// lib/imageStorageDB.ts\r\n// Version: 1.0.0 - 2025-11-10\r\n// Purpose: Handle large image storage using IndexedDB to avoid localStorage quota issues\r\n// IndexedDB has much higher storage limits (typically 50% of free disk space)\r\n\r\nimport { logger } from '@/utils/logger'\r\n\r\nconst DB_NAME = 'CrystalKeepsakesImages'\r\nconst DB_VERSION = 1\r\nconst STORE_NAME = 'cartImages'\r\n\r\ninterface ImageRecord {\r\n  id: string\r\n  productId: string\r\n  dataUrl: string\r\n  thumbnail: string\r\n  metadata: {\r\n    filename?: string\r\n    mimeType?: string\r\n    fileSize?: number\r\n    width?: number\r\n    height?: number\r\n    processedAt?: string\r\n    maskId?: string\r\n    maskName?: string\r\n  }\r\n  timestamp: number\r\n}\r\n\r\nclass ImageStorageDB {\r\n  private db: IDBDatabase | null = null\r\n\r\n  /**\r\n   * Initialize the database\r\n   */\r\n  async init(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(DB_NAME, DB_VERSION)\r\n\r\n      request.onerror = () => {\r\n        logger.error('Failed to open IndexedDB', request.error)\r\n        reject(request.error)\r\n      }\r\n\r\n      request.onsuccess = () => {\r\n        this.db = request.result\r\n        logger.info('IndexedDB initialized successfully')\r\n        resolve()\r\n      }\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result\r\n\r\n        // Create object store if it doesn't exist\r\n        if (!db.objectStoreNames.contains(STORE_NAME)) {\r\n          const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' })\r\n          objectStore.createIndex('productId', 'productId', { unique: false })\r\n          objectStore.createIndex('timestamp', 'timestamp', { unique: false })\r\n          logger.info('Created IndexedDB object store')\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Ensure database is initialized\r\n   */\r\n  private async ensureDb(): Promise<IDBDatabase> {\r\n    if (!this.db) {\r\n      await this.init()\r\n    }\r\n    if (!this.db) {\r\n      throw new Error('Failed to initialize database')\r\n    }\r\n    return this.db\r\n  }\r\n\r\n  /**\r\n   * Store an image in IndexedDB\r\n   */\r\n  async storeImage(\r\n    productId: string,\r\n    dataUrl: string,\r\n    thumbnail: string,\r\n    metadata?: ImageRecord['metadata']\r\n  ): Promise<string> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n      const id = `${productId}_${Date.now()}`\r\n\r\n      const imageRecord: ImageRecord = {\r\n        id,\r\n        productId,\r\n        dataUrl,\r\n        thumbnail,\r\n        metadata: metadata || {},\r\n        timestamp: Date.now()\r\n      }\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readwrite')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const request = objectStore.add(imageRecord)\r\n\r\n        request.onsuccess = () => {\r\n          logger.success('Image stored in IndexedDB', {\r\n            id,\r\n            productId,\r\n            sizeKB: Math.round(dataUrl.length / 1024)\r\n          })\r\n          resolve(id)\r\n        }\r\n\r\n        request.onerror = () => {\r\n          logger.error('Failed to store image', request.error)\r\n          reject(request.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error storing image', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve an image from IndexedDB\r\n   */\r\n  async getImage(id: string): Promise<ImageRecord | null> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readonly')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const request = objectStore.get(id)\r\n\r\n        request.onsuccess = () => {\r\n          const result = request.result\r\n          if (result) {\r\n            logger.info('Image retrieved from IndexedDB', { id })\r\n            resolve(result)\r\n          } else {\r\n            logger.warn('Image not found', { id })\r\n            resolve(null)\r\n          }\r\n        }\r\n\r\n        request.onerror = () => {\r\n          logger.error('Failed to retrieve image', request.error)\r\n          reject(request.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error retrieving image', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all images for a product\r\n   */\r\n  async getProductImages(productId: string): Promise<ImageRecord[]> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readonly')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const index = objectStore.index('productId')\r\n        const request = index.getAll(productId)\r\n\r\n        request.onsuccess = () => {\r\n          const results = request.result || []\r\n          logger.info(`Retrieved ${results.length} images for product`, { productId })\r\n          resolve(results)\r\n        }\r\n\r\n        request.onerror = () => {\r\n          logger.error('Failed to retrieve product images', request.error)\r\n          reject(request.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error retrieving product images', error)\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete an image from IndexedDB\r\n   */\r\n  async deleteImage(id: string): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readwrite')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const request = objectStore.delete(id)\r\n\r\n        request.onsuccess = () => {\r\n          logger.info('Image deleted from IndexedDB', { id })\r\n          resolve()\r\n        }\r\n\r\n        request.onerror = () => {\r\n          logger.error('Failed to delete image', request.error)\r\n          reject(request.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error deleting image', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all images (useful for cart clear)\r\n   */\r\n  async clearAll(): Promise<void> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readwrite')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const request = objectStore.clear()\r\n\r\n        request.onsuccess = () => {\r\n          logger.info('All images cleared from IndexedDB')\r\n          resolve()\r\n        }\r\n\r\n        request.onerror = () => {\r\n          logger.error('Failed to clear images', request.error)\r\n          reject(request.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error clearing images', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up old images (older than 7 days)\r\n   */\r\n  async cleanupOldImages(): Promise<number> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n      const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000)\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readwrite')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const index = objectStore.index('timestamp')\r\n        const range = IDBKeyRange.upperBound(sevenDaysAgo)\r\n        const request = index.openCursor(range)\r\n        \r\n        let deletedCount = 0\r\n\r\n        request.onsuccess = (event) => {\r\n          const cursor = (event.target as IDBRequest).result\r\n          if (cursor) {\r\n            objectStore.delete(cursor.primaryKey)\r\n            deletedCount++\r\n            cursor.continue()\r\n          } else {\r\n            logger.info(`Cleaned up ${deletedCount} old images`)\r\n            resolve(deletedCount)\r\n          }\r\n        }\r\n\r\n        request.onerror = () => {\r\n          logger.error('Failed to cleanup old images', request.error)\r\n          reject(request.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error cleaning up old images', error)\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get database statistics\r\n   */\r\n  async getStats(): Promise<{\r\n    totalImages: number\r\n    estimatedSizeMB: number\r\n  }> {\r\n    try {\r\n      const db = await this.ensureDb()\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const transaction = db.transaction([STORE_NAME], 'readonly')\r\n        const objectStore = transaction.objectStore(STORE_NAME)\r\n        const countRequest = objectStore.count()\r\n        const getAllRequest = objectStore.getAll()\r\n\r\n        countRequest.onsuccess = () => {\r\n          const count = countRequest.result\r\n\r\n          getAllRequest.onsuccess = () => {\r\n            const records = getAllRequest.result || []\r\n            const totalSize = records.reduce((sum, record) => {\r\n              return sum + (record.dataUrl?.length || 0) + (record.thumbnail?.length || 0)\r\n            }, 0)\r\n\r\n            resolve({\r\n              totalImages: count,\r\n              estimatedSizeMB: totalSize / (1024 * 1024)\r\n            })\r\n          }\r\n        }\r\n\r\n        countRequest.onerror = () => {\r\n          reject(countRequest.error)\r\n        }\r\n      })\r\n    } catch (error) {\r\n      logger.error('Error getting database stats', error)\r\n      return { totalImages: 0, estimatedSizeMB: 0 }\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const imageDB = new ImageStorageDB()\r\n\r\n// Initialize on import\r\nif (typeof window !== 'undefined') {\r\n  imageDB.init().catch((error) => {\r\n    logger.error('Failed to initialize ImageStorageDB', error)\r\n  })\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///C:/MAMP/htdocs/crystalkeepsakes/src/lib/cartUtils.ts"],"sourcesContent":["// lib/cartUtils.ts\r\n// Version: 2.0.0 - 2025-11-10 - INDEXEDDB IMAGE STORAGE\r\n// Fixed: Moved image storage to IndexedDB to avoid localStorage quota issues\r\n// - Images stored in IndexedDB (50% of free disk space limit)\r\n// - Only image IDs stored in localStorage cart\r\n// - Automatic cleanup of orphaned images\r\n// - Better error handling and recovery\r\n\r\nimport { logger } from '@/utils/logger'\r\nimport { imageDB } from './imageStorageDB'\r\nimport { uploadImageStorage } from './api/upload-image.php'\r\n\r\nexport interface CartItem {\r\n  productId: string\r\n  name: string\r\n  sku: string\r\n  price: number\r\n  quantity: number\r\n  options: any\r\n  sizeDetails?: any\r\n  customImageId?: string  // Changed from customImage object to just ID\r\n  customImageMetadata?: {  // Light metadata for display\r\n    filename?: string\r\n    maskName?: string\r\n    hasImage: boolean\r\n  }\r\n  cockpit3d_id?: string\r\n  dateAdded: string\r\n}\r\n\r\n/**\r\n * Compress image to TINY thumbnail for cart display\r\n * Reduces base64 size by ~97% (e.g., 2MB -> 60KB)\r\n */\r\nasync function compressImageToThumbnail(dataUrl: string): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image()\r\n    img.onload = () => {\r\n      const canvas = document.createElement('canvas')\r\n      const MAX_SIZE = 100 // Small thumbnail size\r\n      let width = img.width\r\n      let height = img.height\r\n      \r\n      // Maintain aspect ratio\r\n      if (width > height) {\r\n        if (width > MAX_SIZE) {\r\n          height = (height * MAX_SIZE) / width\r\n          width = MAX_SIZE\r\n        }\r\n      } else {\r\n        if (height > MAX_SIZE) {\r\n          width = (width * MAX_SIZE) / height\r\n          height = MAX_SIZE\r\n        }\r\n      }\r\n      \r\n      canvas.width = width\r\n      canvas.height = height\r\n      const ctx = canvas.getContext('2d')!\r\n      ctx.drawImage(img, 0, 0, width, height)\r\n      \r\n      // Lower quality JPEG for minimal size\r\n      resolve(canvas.toDataURL('image/jpeg', 0.5))\r\n    }\r\n    img.onerror = () => reject(new Error('Image compression failed'))\r\n    img.src = dataUrl\r\n  })\r\n}\r\n\r\n/**\r\n * Clean options object - remove ALL image data URLs\r\n */\r\nfunction cleanOptions(options: any): any {\r\n  if (!options) return {}\r\n  \r\n  const cleaned = { ...options }\r\n  \r\n  // Remove all image data URLs from options\r\n  delete cleaned.rawImageUrl\r\n  delete cleaned.imageUrl\r\n  delete cleaned.maskedImageUrl\r\n  delete cleaned.dataUrl\r\n  delete cleaned.customImage\r\n  \r\n  // Keep only essential metadata\r\n  return {\r\n    size: cleaned.size,\r\n    background: cleaned.background,\r\n    lightBase: cleaned.lightBase,\r\n    giftStand: cleaned.giftStand,\r\n    customText: cleaned.customText,\r\n    // Only keep image filenames, not data URLs\r\n    imageFilename: cleaned.imageFilename,\r\n    maskName: cleaned.maskName\r\n  }\r\n}\r\n\r\n/**\r\n * Add item to cart with IndexedDB image storage\r\n */\r\nexport async function addToCart(item: CartItem | any): Promise<void> {\r\n  logger.order('Adding item to cart', {\r\n    productId: item.productId,\r\n    hasCustomImage: !!item.customImage?.dataUrl || !!item.options?.maskedImageUrl\r\n  })\r\n  \r\n  try {\r\n    const cart = getCart()\r\n    let customImageId: string | undefined\r\n    let customImageMetadata: CartItem['customImageMetadata'] | undefined\r\n    \r\n    // Handle custom image storage in IndexedDB\r\n    const imageDataUrl = item.customImage?.dataUrl || item.options?.maskedImageUrl\r\n    if (imageDataUrl) {\r\n      try {\r\n        // Compress thumbnail\r\n        const thumbnail = await compressImageToThumbnail(imageDataUrl)\r\n        \r\n        // Store full image and thumbnail in IndexedDB\r\n        customImageId = await imageDB.storeImage(\r\n          item.productId,\r\n          imageDataUrl,\r\n          thumbnail,\r\n          {\r\n            filename: item.customImage?.filename || item.options?.imageFilename,\r\n            mimeType: item.customImage?.mimeType || 'image/png',\r\n            fileSize: item.customImage?.fileSize || imageDataUrl.length,\r\n            width: item.customImage?.width,\r\n            height: item.customImage?.height,\r\n            processedAt: item.customImage?.processedAt || new Date().toISOString(),\r\n            maskId: item.customImage?.maskId || item.options?.maskId,\r\n            maskName: item.customImage?.maskName || item.options?.maskName\r\n          }\r\n        )\r\n        \r\n        customImageMetadata = {\r\n          filename: item.customImage?.filename || item.options?.imageFilename,\r\n          maskName: item.customImage?.maskName || item.options?.maskName,\r\n          hasImage: true\r\n        }\r\n        \r\n        logger.success('Image stored in IndexedDB', {\r\n          imageId: customImageId,\r\n          originalSizeKB: Math.round(imageDataUrl.length / 1024),\r\n          thumbnailSizeKB: Math.round(thumbnail.length / 1024)\r\n        })\r\n      } catch (error) {\r\n        logger.error('Failed to store image in IndexedDB', error)\r\n        // Continue without image rather than fail entire add\r\n        customImageId = undefined\r\n        customImageMetadata = { hasImage: false }\r\n      }\r\n    }\r\n    \r\n    // Clean options to remove any image data\r\n    const cleanedOptions = cleanOptions(item.options)\r\n    \r\n    // Create cart item with just image ID reference\r\n    const cartItem: CartItem = {\r\n      productId: item.productId,\r\n      name: item.name,\r\n      sku: item.sku,\r\n      price: item.price || item.totalPrice,\r\n      quantity: item.quantity,\r\n      options: cleanedOptions,\r\n      sizeDetails: item.size || item.sizeDetails,\r\n      customImageId,\r\n      customImageMetadata,\r\n      cockpit3d_id: item.cockpit3d_id,\r\n      dateAdded: item.dateAdded || new Date().toISOString()\r\n    }\r\n    \r\n    cart.push(cartItem)\r\n    saveCart(cart)\r\n    \r\n    // Clean up old images periodically\r\n    if (Math.random() < 0.1) { // 10% chance on each add\r\n      imageDB.cleanupOldImages().catch(err => \r\n        logger.warn('Background image cleanup failed', err)\r\n      )\r\n    }\r\n    \r\n    logger.success('Item added to cart', { \r\n      totalItems: cart.length,\r\n      hasImage: !!customImageId\r\n    })\r\n  } catch (error) {\r\n    logger.error('Failed to add item to cart', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Get cart from localStorage\r\n */\r\nexport function getCart(): CartItem[] {\r\n  try {\r\n    const cartData = localStorage.getItem('cart')\r\n    return cartData ? JSON.parse(cartData) : []\r\n  } catch (error) {\r\n    logger.error('Failed to read cart', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Get cart with images loaded from IndexedDB\r\n */\r\nexport async function getCartWithImages(): Promise<Array<CartItem & { \r\n  customImage?: { \r\n    dataUrl: string\r\n    thumbnail: string\r\n    metadata: any\r\n  } \r\n}>> {\r\n  const cart = getCart()\r\n  \r\n  // Load images from IndexedDB\r\n  const cartWithImages = await Promise.all(\r\n    cart.map(async (item) => {\r\n      if (item.customImageId) {\r\n        try {\r\n          const imageRecord = await imageDB.getImage(item.customImageId)\r\n          if (imageRecord) {\r\n            return {\r\n              ...item,\r\n              customImage: {\r\n                dataUrl: imageRecord.dataUrl,\r\n                thumbnail: imageRecord.thumbnail,\r\n                metadata: imageRecord.metadata\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          logger.warn(`Failed to load image for cart item`, { \r\n            productId: item.productId,\r\n            imageId: item.customImageId,\r\n            error \r\n          })\r\n        }\r\n      }\r\n      return item\r\n    })\r\n  )\r\n  \r\n  return cartWithImages\r\n}\r\n\r\n/**\r\n * Save cart to localStorage (without images)\r\n */\r\nexport function saveCart(cart: CartItem[]): void {\r\n  try {\r\n    const cartJson = JSON.stringify(cart)\r\n    const sizeKB = (cartJson.length / 1024).toFixed(2)\r\n    \r\n    logger.info('Saving cart to localStorage', { \r\n      items: cart.length, \r\n      sizeKB,\r\n      hasImages: cart.filter(item => item.customImageId).length\r\n    })\r\n    \r\n    localStorage.setItem('cart', cartJson)\r\n    \r\n    // Dispatch custom event to notify all listeners\r\n    const event = new CustomEvent('cartUpdated', { \r\n      detail: { \r\n        itemCount: cart.length,\r\n        totalItems: cart.reduce((sum, item) => sum + item.quantity, 0)\r\n      } \r\n    })\r\n    window.dispatchEvent(event)\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Failed to save cart', error)\r\n    \r\n    if (error.name === 'QuotaExceededError') {\r\n      // This should be rare now since images are in IndexedDB\r\n      // Try clearing some old data\r\n      try {\r\n        cleanupLocalStorage()\r\n        localStorage.setItem('cart', JSON.stringify(cart))\r\n        logger.warn('Cart saved after cleanup')\r\n      } catch (fallbackError) {\r\n        throw new Error('Unable to save cart. Please clear browser data.')\r\n      }\r\n    } else {\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Remove item from cart by index\r\n */\r\nexport async function removeFromCart(index: number): Promise<CartItem[]> {\r\n  const cart = getCart()\r\n  const removedItem = cart[index]\r\n  \r\n  // Delete associated image from IndexedDB\r\n  if (removedItem?.customImageId) {\r\n    try {\r\n      await imageDB.deleteImage(removedItem.customImageId)\r\n      logger.info('Deleted image from IndexedDB', { \r\n        imageId: removedItem.customImageId \r\n      })\r\n    } catch (error) {\r\n      logger.warn('Failed to delete image from IndexedDB', error)\r\n    }\r\n  }\r\n  \r\n  cart.splice(index, 1)\r\n  saveCart(cart)\r\n  return cart\r\n}\r\n\r\n/**\r\n * Clear entire cart and all images\r\n */\r\nexport async function clearCart(): Promise<void> {\r\n  localStorage.removeItem('cart')\r\n  \r\n  // Clear all images from IndexedDB\r\n  try {\r\n    await imageDB.clearAll()\r\n    logger.info('Cleared all images from IndexedDB')\r\n  } catch (error) {\r\n    logger.warn('Failed to clear images from IndexedDB', error)\r\n  }\r\n  \r\n  window.dispatchEvent(new CustomEvent('cartUpdated', { \r\n    detail: { itemCount: 0, totalItems: 0 } \r\n  }))\r\n}\r\n\r\n/**\r\n * Get total item count\r\n */\r\nexport function getCartItemCount(): number {\r\n  const cart = getCart()\r\n  return cart.reduce((sum, item) => sum + item.quantity, 0)\r\n}\r\n\r\n/**\r\n * Get cart total price\r\n */\r\nexport function getCartTotal(): number {\r\n  const cart = getCart()\r\n  return cart.reduce((sum, item) => sum + (item.price * item.quantity), 0)\r\n}\r\n\r\n/**\r\n * Check localStorage health\r\n */\r\nexport function checkStorageHealth(): { \r\n  isHealthy: boolean\r\n  usedSpace: number\r\n  totalSpace: number\r\n  percentUsed: number\r\n  message?: string\r\n} {\r\n  try {\r\n    let totalSize = 0\r\n    for (let key in localStorage) {\r\n      if (localStorage.hasOwnProperty(key)) {\r\n        totalSize += localStorage[key].length + key.length\r\n      }\r\n    }\r\n    \r\n    // Most browsers have 5MB limit\r\n    const STORAGE_LIMIT = 5242880\r\n    const percentUsed = (totalSize / STORAGE_LIMIT) * 100\r\n    \r\n    logger.info('Storage health check', {\r\n      usedKB: (totalSize / 1024).toFixed(2),\r\n      percentUsed: percentUsed.toFixed(1) + '%'\r\n    })\r\n    \r\n    return {\r\n      isHealthy: percentUsed < 90,\r\n      usedSpace: totalSize,\r\n      totalSpace: STORAGE_LIMIT,\r\n      percentUsed,\r\n      message: percentUsed > 80 ? 'Storage nearly full' : undefined\r\n    }\r\n    \r\n  } catch (error) {\r\n    logger.error('Storage health check failed', error)\r\n    return {\r\n      isHealthy: false,\r\n      usedSpace: 0,\r\n      totalSpace: 0,\r\n      percentUsed: 100,\r\n      message: 'Storage check failed'\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up unnecessary data from localStorage\r\n */\r\nfunction cleanupLocalStorage(): void {\r\n  try {\r\n    // Remove old/temporary data\r\n    const keysToCheck = Object.keys(localStorage)\r\n    keysToCheck.forEach(key => {\r\n      // Remove old temporary data\r\n      if (key.startsWith('temp_') || key.startsWith('old_')) {\r\n        localStorage.removeItem(key)\r\n      }\r\n    })\r\n    logger.info('Cleaned up localStorage')\r\n  } catch (error) {\r\n    logger.error('localStorage cleanup failed', error)\r\n  }\r\n}\r\n\r\n/**\r\n * Get IndexedDB stats\r\n */\r\nexport async function getImageStorageStats() {\r\n  try {\r\n    const stats = await imageDB.getStats()\r\n    return {\r\n      ...stats,\r\n      storageHealth: checkStorageHealth()\r\n    }\r\n  } catch (error) {\r\n    logger.error('Failed to get storage stats', error)\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Estimate size of data to be stored (backward compatibility)\r\n */\r\nexport function estimateSize(data: any): number {\r\n  try {\r\n    return JSON.stringify(data).length\r\n  } catch (error) {\r\n    logger.error('Failed to estimate data size', error)\r\n    return 0\r\n  }\r\n}\r\n\r\n/**\r\n * Store full-resolution image (backward compatibility)\r\n * Now uses IndexedDB instead of sessionStorage\r\n */\r\nexport async function storeFullResImage(productId: string, dataUrl: string): Promise<void> {\r\n  try {\r\n    // Create a thumbnail for storage\r\n    const thumbnail = await compressImageToThumbnail(dataUrl)\r\n    \r\n    // Store in IndexedDB\r\n    await imageDB.storeImage(\r\n      productId,\r\n      dataUrl,\r\n      thumbnail,\r\n      {\r\n        processedAt: new Date().toISOString()\r\n      }\r\n    )\r\n    \r\n    logger.info('Full-res image stored in IndexedDB', { \r\n      productId, \r\n      sizeKB: (dataUrl.length / 1024).toFixed(2) \r\n    })\r\n  } catch (error) {\r\n    logger.error('Failed to store full-res image', error)\r\n    \r\n    // Fallback to sessionStorage for backward compatibility\r\n    try {\r\n      sessionStorage.setItem(`fullimg_${productId}`, dataUrl)\r\n      logger.warn('Fell back to sessionStorage for image storage')\r\n    } catch (e) {\r\n      logger.error('All image storage methods failed', e)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieve full-resolution image (backward compatibility)\r\n * Checks both IndexedDB and sessionStorage\r\n */\r\nexport async function getFullResImage(productId: string): Promise<string | null> {\r\n  try {\r\n    // First try IndexedDB\r\n    const images = await imageDB.getProductImages(productId)\r\n    if (images.length > 0) {\r\n      return images[0].dataUrl\r\n    }\r\n    \r\n    // Fallback to sessionStorage\r\n    const sessionImage = sessionStorage.getItem(`fullimg_${productId}`)\r\n    if (sessionImage) {\r\n      logger.info('Retrieved image from sessionStorage fallback')\r\n      return sessionImage\r\n    }\r\n    \r\n    return null\r\n  } catch (error) {\r\n    logger.error('Could not retrieve full-res image', error)\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Migrate old cart format to new format (for backwards compatibility)\r\n */\r\nexport async function migrateOldCart(): Promise<void> {\r\n  try {\r\n    const cart = getCart()\r\n    let needsMigration = false\r\n    \r\n    const migratedCart = await Promise.all(\r\n      cart.map(async (item: any) => {\r\n        // Check if item has old format with embedded image\r\n        if (item.customImage?.dataUrl && !item.customImageId) {\r\n          needsMigration = true\r\n          \r\n          try {\r\n            // Store image in IndexedDB\r\n            const thumbnail = await compressImageToThumbnail(item.customImage.dataUrl)\r\n            const imageId = await imageDB.storeImage(\r\n              item.productId,\r\n              item.customImage.dataUrl,\r\n              thumbnail,\r\n              item.customImage\r\n            )\r\n            \r\n            // Return migrated item\r\n            return {\r\n              ...item,\r\n              customImageId: imageId,\r\n              customImageMetadata: {\r\n                filename: item.customImage.filename,\r\n                maskName: item.customImage.maskName,\r\n                hasImage: true\r\n              },\r\n              customImage: undefined // Remove embedded image\r\n            }\r\n          } catch (error) {\r\n            logger.warn('Failed to migrate image for item', { \r\n              productId: item.productId, \r\n              error \r\n            })\r\n            return {\r\n              ...item,\r\n              customImage: undefined\r\n            }\r\n          }\r\n        }\r\n        return item\r\n      })\r\n    )\r\n    \r\n    if (needsMigration) {\r\n      saveCart(migratedCart)\r\n      logger.info('Cart migrated to new format')\r\n    }\r\n  } catch (error) {\r\n    logger.error('Cart migration failed', error)\r\n  }\r\n}\r\n\r\n// Auto-migrate on load\r\nif (typeof window !== 'undefined') {\r\n  migrateOldCart().catch(err => \r\n    logger.warn('Auto-migration failed', err)\r\n  )\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 762, "column": 0}, "map": {"version":3,"sources":["file:///C:/MAMP/htdocs/crystalkeepsakes/node_modules/%40swc/helpers/esm/_define_property.js"],"sourcesContent":["function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n    } else obj[key] = value;\n\n    return obj;\n}\nexport { _define_property as _ };\n"],"names":[],"mappings":";;;AAAA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IACzG,OAAO,GAAG,CAAC,IAAI,GAAG;IAElB,OAAO;AACX","ignoreList":[0],"debugId":null}}]
}